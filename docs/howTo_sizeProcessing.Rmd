---
title: "How to Add a New Size Processor"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(nimble)
```

This guide first briefly describes the size processing system in NIMBLE.  It then describes the process of adding a new size processor and lists some commonly used size processors.  Note that NIMBLE's size processing functionality can largely be found in [genCpp_sizeProcessing.R](https://github.com/nimble-dev/nimble/blob/devel/packages/nimble/R/genCpp_sizeProcessing.R).


## Size Processing Overview


The size processing step in NIMBLE proceeds by traveling recursively through the syntax tree, annotating each node with dimensionality, type, and eigenizability (yes, no, or maybe for conversion to C++ Eigen package code).  It also generates run-time size checks, inserts intermediate variables, and populates the local symbol table with locally created objects. 

Each node of the syntax tree (as given by the `code` argument to a size processor) should exit the size processor with the following fields set:

* `code$nDim`: the dimension of the object.  Must be an integer.
* `code$type`: the type of the object, e.g. "double"
* `code$sizeExprs`: usually, a list of length nDim, where entries are expressions for the size of the object in that dimension. List entries can be constants, e.g. `sizeExprs[[1]] = 5` it was known that the first dimension of this object will have length 5.  Alternatively, a `sizeExprs` list entry could be a generic expression, e.g. `sizeExprs[[1]] <- dim(x)[1]`, ensuring that the first dimension of this object will be the same sa the size of the first dimension of the `x` object.  
    * Generic `sizeExprs` in some instances should be set using one of two functions: 
        * The `productSizeExprs()`function should be used if the `sizeExprs` for the current node should be a single dimension, the size of which is the product of the dimensions of the `sizeExprs` of another node  
        * The  `makeSizeExpressions()`  function (located in genCpp_initSizes.R) should be used when `sizeExprs` for a node are a combination of constants and expressions 
    * An exception to this is that for a syntax tree node representing a `nimbleList` or a `nimbleFunction`, `code$sizeExprs` will contain the `symbolTable` entry of the corresponding `nimbleList` or `nimbleFunction`.  This alows information from these objects (e.g. the elements of a `nimbleList`) to be easily accessed at other parts of size processing.  
* `code$toEigenize`: either `yes`, `no`, or `maybe`.  Indicates whether to convert node to a type from the C++ Eigen package.
* `code$name`: the name of the node being size processed.

Note that some or all of these fields may be set by other functions called within a size processor (e.g. `makeSizeExpressions()`), and as such do not necessarily need to be explicitly set within the processor itself.

Size processors collect additional expressions, called `asserts`, that are later inserted into the syntax tree and become lines of code.  `asserts` may be collected for each line of code that is size processed, and the lines of code generated by the `asserts` can be inserted either before or after the expression they are `assert`-ed from.  `asserts` are frequently run-time size checks, but can also be used to create intermediate variables, among other uses.  For an example of generating `asserts` that go both before and after a line of code, see the `sizeasDoublePtr()` size processor.

## Adding a New Size Processor

* Any new size processing function must take the following arguments:
    * `code`: the expression class object representing the node of the syntax tree
    * `symTab`: the symbol table for the nimbleFunction method that is currently being size processed
    * `typeEnv`: an environment with size expressions for known objects.  See additional information at top of `genCpp_initSizes.R`.
* Any new size processor should set the `code` fields described in [Size Processing Overview](#size-processing-overview)
* If another size processor is called from within the new size processor (e.g. `sizeInsertIntermediate()` is commonly called from within a size processor), be sure to collect the `asserts` returned by that size processor. Size processing functions can also create their own `asserts` expressions.  Any `asserts` either created or collected within a size processor should be returned from that size processor.  If it is known that no `asserts` exist at the end of a size processor, an empty `list()` should be returned.

* Any new size processing function must be added to the `sizeCalls` list, located at the top of [genCpp_sizeProcessing.R](https://github.com/nimble-dev/nimble/blob/devel/packages/nimble/R/genCpp_sizeProcessing.R).  The entry should be of the form `fxnName = 'sizeProcessorName'`, where `fxnName` is the name of the DSL function to be size processed, and `'sizeProcessorName'` is a character string naming the new size processing function.



## Commonly Used Size Processors

* `exprClasses_setSizes()`:  See note above the `exprClasses_setSizes()` function in [genCpp_sizeProcessing.R](https://github.com/nimble-dev/nimble/blob/devel/packages/nimble/R/genCpp_sizeProcessing.R) for more information.
* `sizeInsertIntermediate()`:  Used to lift a node, creating an intermediate node.  Useful especially in situations where a part of a line of code needs to be eigenized.  
* `sizeAssignAfterRecursing()`:  The main size processor for assignment operations.  Called after the left and right hand sides of an assignment operation have been annotated.  This processor considers all valid combinations of left hand and right hand side types for an assignment operations, and as such is rather long.
* `recurseSetSizes()`: Recursively annotates arguments of a node in the syntax tree.  Should generally be called at the beginning of a size processor if that node's arguments may need processing. 
