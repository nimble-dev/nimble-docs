\Sexpr{set_parent('NimbleUserManual.Rnw')}

<<echo=FALSE>>=
require(nimble)
@ 

\chapter{Data structures in NIMBLE}
\label{cha:data-structures}

NIMBLE provides several data structures useful for programming.

We'll first describe \cd{modelValues}, which are containers designed for
storing values for models. Then we'll describe \cd{nimbleLists}, which have a similar purpose to lists in R, allowing you to store heterogeneous information in a single object. 

modelValues and nimbleLists can be created in either R or in nimbleFunction setup code.  They can then be used either in R or in nimbleFunction run code. If used in run code, they will be compiled along with the nimbleFunction.

{\color{red} Nick et al., please clean up this language and make sure it is accurate/precise in terms of configuration vs instantiation.}


\section{The \nm{modelValues} data structure}
\label{sec:modelValues-struct}

\cd{modelValues} are containers designed for
storing values for models.  They may be used for model outputs or
model inputs. A modelValues object will contain \emph{rows} of
variables. Each row  contains one object of each variable, which may
be multivariate. The simplest way to build a
modelValues object is from a model object. This will create a
modelValues object with the same variables as the model.  Although
they were motivated by models, one is free to set up a
\cd{modelValues} with any variables one wants.

As with the material in the rest of this chapter, modelValues objects
will generally be used in nimbleFunctions that interact with models
(see Chapter \ref{cha:progr-with-models}, so one may want to read this
section after an inital reading of that chapter. modelValues objects can
be defined either in setup code or separately in R (and then passed as
an argument to setup code). The modelValues object can then used in run code of nimbleFunctions.
 
\subsection{Creating modelValues objects}

Here is a simple example of creating a modelValues object:

<<intro-mv>>=
pumpModelValues = modelValues(pumpModel, m = 2)
pumpModel$x
pumpModelValues$x
@


In this example, \cd{pumpModelValues} has the same variables as
\cd{pumpModel}, and we set \cd{pumpModelValues} to have \cd{m = 2}
rows. As you can see, the rows are stored as elements of a list.
  
  Alternatively, one can define a modelValues object manually via the
  \cd{modelValuesConf} function, like this:
%%   \begin{itemize}
%%  \item \cd{vars}, which is a character vector of variable names, 
%%    \item \cd{type}, which is a character vector of the data types for each variable (`double' for real numbers, `integer' for integers) and 
%%      \item \cd{size}, which is a list of vectors of the sizes in each dimension of each variable. The names of the list elements must match the names provided in \cd{vars}. 
%% \end{itemize}

<<mvConf>>=
mvConf = modelValuesConf(vars = c('a', 'b', 'c'), 
                         type = c('double', 'int', 'double'), 
                         size = list( a = 2, b =c(2,2)  , c = 1) )

customMV = modelValues(mvConf, m = 2 )
customMV$a
@

The arguments to \cd{modelValuesConf} are matching lists of variable
names, types, and sizes. See \cd{help(modelValuesConf)} for more
details.  Note that in R execution, the types are not enforced.  But
they will be the types created in C++ code during compilation, so they
should be specified carefully.

The object returned by \cd{modelValues} is an uncompiled
modelValues. When a nimbleFunction is compiled, any modelValues
objects it uses are also compiled. A NIMBLE model always contains a
modelValues that it uses as a default location to store its variables.

Here is an example where the \cd{customMV} created above is used as
the setup argument for a nimbleFunction, which is then compiled.  Its
compiled mv is then accessed with \cd{\$}.

<<resize_MV>>=
# Simple nimbleFunction that uses a modelValues object
resizeFunction_Gen <- nimbleFunction(
  setup = function(mv){},
  run = function(k = integer() ){
    resize(mv,k)})

rResize <- resizeFunction_Gen(customMV)
cResize <- compileNimble(rResize)
cCustomMV <- cResize$mv
# cCustomMV is a C++ modelValues object
@

Compiled modelValues objects can be accessed and altered in all the
same ways as uncompiled ones.  However, only uncompiled modelValues
can be used as arguments to setup code in nimbleFunctions.

\subsection{Accessing contents of modelValues}
\label{sec:access-cont-modelv}

The values in a modelValues object can be accessed in several ways
from R, and in fewer ways from NIMBLE.

<<mv-access>>=
# Sets the first row of a to (0, 1).  R only.
customMV[['a']][[1]] <- c(0,1)   

# Sets the second row of a to (2, 3)
customMV['a', 2] <- c(2,3)       

#Can access subsets of each row in standard R manner
customMV['a', 2][2] <- 4

# Accesses all values of 'a'. Output is a list.  R only.
customMV[['a']]                  

# Sets the first row of b to a matrix with values 1. R only.
customMV[['b']][[1]] <- matrix(1, nrow = 2, ncol = 2)  

# Sets the second row of b.  R only.
customMV[['b']][[2]] <- matrix(2, nrow = 2, ncol = 2)  

# Make sure the size of inputs is correct
# customMV['a', 1] <- 1:10  
# Problem: dimension of 'a' is 2, not 10!
# Will cause problems when compiling nimbleFunction using customMV
@

Currently, only the syntax \cd{customMV[`a', 2]} works in the NIMBLE
language, not \cd{customMV[[`a']][[2]]}. Also note that \cd{c()} does not work in NIMBLE, but one can do \cd{customMV[`a', 2] <- X[1:2]}.

We can query and change the number of rows using \cd{getsize} and
\cd{resize}, respectively.  These work in both R and NIMBLE.  Note
that we don't specify the variables in this case: all variables in a
modelValues object will have the same number of rows.
  
<<resize-mv>>=
getsize(customMV)
resize(customMV, 3)
getsize(customMV)
customMV$a
@

Often it is useful to convert a modelValues object to a matrix for use
in R.  For example, we may want to convert MCMC output into a matrix
for use with the \cd{coda} package for processing MCMC samples. This
can be done with the \cd{as.matrix} method for modelValues
objects. This will generate column names from every scalar element of
variables (e.g. "x[1, 1]" ,"x[2, 1]", etc.). The rows of
the modelValues will be the rows of the matrix, with any matrices or
arrays converted to a vector based on column-major ordering.
  
<<as.matrix-mv>>=
as.matrix(customMV, 'a')   # convert 'a'
as.matrix(customMV)        # convert all variables
@

If a variable is a scalar, using \cd{unlist} in R to extract all rows as a vector can be useful.

<<extract_MV_Vector>>=
customMV['c', 1] <- 1
customMV['c', 2] <- 2
customMV['c', 3] <- 3
unlist(customMV['c', ])
@

Once we have a modelValues object, we can see the structure of its
contents via the \cd{varNames} and \cd{sizes} components of the object.

<<mv_VarNames_Sizes>>=
customMV$varNames
customMV$sizes
@

As with most NIMBLE objects, modelValues are passed by reference, not
by value. That means any modifications of modelValues objects in
either R functions or \cd{nimbleFunction}s will persist outside of the
function. This allows for more efficient computation, as stored values
are immediately shared among \cd{nimbleFunction}s.

<<alter_a>>=
alter_a <- function(mv){
  mv['a',1][1] <- 1
}
customMV['a', 1]

alter_a(customMV)
customMV['a',1]

#Note that the first row was changed
@

However, when you retrieve a variable from a modelValues object, the result is a standard R list, which is subsequently passed by value, as usual in R.



\subsubsection{Automating calculation and simulation using modelValues}



The nimbleFunctions \cd{simNodesMV}, \cd{calcNodesMV}, and \cd{getLogProbsMV}}
can be used to operate on a model based on rows in a modelValues object.
For example,
\cd{simNodesMV} will simulate in the model multiple times and record
each simulation in a row of its modelValues.  \cd{calcNodesMV} and
\cd{getLogProbsMV} iterate over the rows of a modelValues, copy the
nodes into the model, and then do their job of calculating or
collecting log probabilities (densities), respectively.  Each of these
returns a numeric vector with the summed log probabilities of the
chosen nodes from each
each row. \cd{calcNodesMV} will 
  save the log probabilities back into the modelValues object if
  \cd{saveLP == TRUE}, a run-time argument. 

Here are some examples:

<<Basic_Utils_MV>>=
mv <- modelValues(simpleModel)
rSimManyXY <- simNodesMV(simpleModel, nodes = c('x', 'y'), mv = mv)
rCalcManyXDeps <- calcNodesMV(simpleModel, nodes = 'x', mv = mv)
rGetLogProbMany <- getLogProbNodesMV(simpleModel,
                    nodes = 'x', mv = mv)

cSimManyXY <- compileNimble(rSimManyXY, project = simpleModel)
cCalcManyXDeps <- compileNimble(rCalcManyXDeps, project = simpleModel)
cGetLogProbMany <- compileNimble(rGetLogProbMany, project = simpleModel)

cSimManyXY$run(m = 5) # simulating 5 times
cCalcManyXDeps$run(saveLP = TRUE) # calculating 
cGetLogProbMany$run() #
@
  
\section{The \nm{nimbleList} data structure}
\label{sec:modelValues-struct}
