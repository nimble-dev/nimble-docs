%% See http://yihui.name/knitr/demo/child/ for documentation on the parent/child document system of knitr

\Sexpr{set_parent('NimbleUserManual.Rnw')}

<<echo=FALSE>>=
require(nimble)
@ 

\chapter{Writing \cd{nimbleFunction}s  that interact with models}
\label{cha:progr-with-models}

<<echo=FALSE>>=
read_chunk(file.path('chunks', 'programmingWithModels_chunks.R')) 
@ 



\section{Overview}
\label{sec:writ-nimble-funct}

When you write an R function, you say what the input arguments are,
you provide the code for execution, and in that code you give the
returned value\footnote{normally the value of the last
  evaluated code, or the argument to return().}.  Using the
\cd{function} keyword in R triggers the operation of
creating an object that is the function.

Creating nimbleFunctions is similar, but there
are two kinds of code and two steps of execution:

\begin{enumerate}
\item \cd{Setup} code is provided as a regular R function, but the
  programmer does not control what it returns.  Typically the inputs to
  \cd{setup} code are objects like a model, a vector of nodes,
  a modelValues object or modelValuesConf, or another nimbleFunction.  The \cd{setup} code,
  as its name implies, sets up information for run-time code.  It is
  executed in R, so it can use any aspect of R.
\item \cd{Run} code is provided in the NIMBLE language.  This is
  similar to a narrow subset of R, but it is important to remember
  that it is different -- defined by what can be compiled -- and much more limited.  \cd{Run} code can
  use the objects created by the \cd{setup} code.  In addition,
  some information on variable types must be provided for input
  arguments, the return object, and in some circumstances for local
  variables. There are two
  kinds of \cd{run} code:
  \begin{enumerate}
  \item There is always a primary function, given as an argument
    called \cd{run}\footnote{This can be omitted if you don't need it.}.
  \item There can optionally be other functions, or ``methods'' in the
    language of object-oriented programming, that share the same
    objects created by the \cd{setup} function.
  \end{enumerate}
\end{enumerate}

Here is a small example to fix ideas:

<<nf-intro>>=
@ 

The call to the R function called \cd{nimbleFunction} returns a
function, similarly to defining a function in R. That function,
\cd{logProbCalcPlus}, takes arguments for its \cd{setup} function,
executes it, and returns an object, \cd{logProbCalcPlusA}, that has a
\nm{run} member function (method) accessed by \cd{\$run}.  In this case, the
\cd{setup} function obtains the stochastic dependencies of the
\cd{node} using the \cd{getDependencies} member function of the model
(see Section \ref{sec:cdgetdependencies}) and stores them in
\cd{dependentNodes}.  In this way, \cd{logProbCalcPlus} can adapt to any
model.  It also creates a variable, \cd{valueToAdd}, that can be used by the nimbleFunction.

The object \cd{logProbCalcPlusA}, returned by \cd{logProbCalcPlus},
is permanently bound to the results of the processed \cd{setup}
function.  In this case, \cd{logProbCalcPlusA\$run} takes a scalar input value, \cd{P},
assigns \cd{P + valueToAdd} to
the given node in the model, and returns the sum of the log
probabilities of that node and its stochastic
dependencies\footnote{Note the use of the global assignment operator
  to assign into the model.  This is necessary for assigning into
  variables from the \cd{setup} function, at least if you want to void
  warnings from R.  These warnings come from R's reference class
  system.}.  We say  \cd{logProbCalcPlusA} is an ``instance'' of
\cd{logProbCalcPlus} that is
``specialized'' or ``bound'' to \cd{a} and \cd{testModel}.  Usually, the
\cd{setup} code will be where information about the model
structure is determined, and then the \cd{run} code can use that
information without repeatedly, redundantly recomputing it.  A nimbleFunction can
be called repeatedly, each time returning a specialized nimbleFunction.
  
Readers familiar with object-oriented programming may find it useful
to think in terms of class definitions and objects.  \cd{nimbleFunction}
creates a class definition.  Each specialized nimbleFunction is one object
in the class.  The setup arguments are used to define member data in
the object.


\section{Using and compiling nimbleFunctions}
\label{sec:using-comp-nimbl}

To compile the nimbleFunction, together with its model, we use \cd{compileNimble}:

<<nf-compiling>>=
@ 

These have been initialized with the values from their uncompiled
versions and can be used in the same way:

<<nf-using>>=
@ 

\section{Writing setup code}

\subsection{Useful tools for \cd{setup} functions}

The setup function is typically used to determine information on nodes
in a model, set up any modelValues objects, set up any nimbleFunctions
or nimbleFunctionLists, and set up any persistent numeric objects.
For example, the \cd{setup} code of an MCMC nimbleFunction creates the
nimbleFunctionList of sampler nimbleFunctions.  The values of numeric
objects created in \cd{setup} can be modified by run code and will
persist across calls.

Some of the useful tools and objects to create in \cd{setup} functions include

\begin{description}
\item[vectors of node names] Often these are obtained from the
  \cd{getNodeNames} and \cd{getDependencies} methods of a model,
  described in Section \ref{sec:cdgetn-cdgetv}.
\item[modelValues objects] These are discussed more below.
\item[specializations of other nimbleFunctions] A useful NIMBLE
  programming technique is to have one nimbleFunction contain other
  nimbleFunctions, which it can use in its run-time code.
\item[lists of other nimbleFunctions] In addition to containing single
  other nimbleFunctions, a nimbleFunction can contain a list of other
  nimbleFunctions.  These are discussed more below.
\end{description}

If one wants a nimbleFunction that does get specialized but has
empty setup code, use \cd{setup = function() \{\}} or \cd{setup = TRUE}.

\subsection{Accessing and modifying numeric values from setup}
\label{sec:access-modify-numer}

While models and nodes created during \cd{setup} cannot be
modified\footnote{Actually, they can be, but only for uncompiled nimbleFunctions},
numeric values and modelValues (see below) can be.  For example:

<<nf-modifyValueToAdd>>=
@ 


\subsection{Control of \cd{setup} outputs }
\label{sec:determ-pers-texttts}

Sometimes \cd{setup} code may create variables that are not used in
run-time code.  By default, NIMBLE inspects run-time code and omits
variables from \cd{setup} that do not appear in run-time code from
compilation.  However, sometimes a programmer may want to force a
numeric or character variable to be created in compilation, even if it
is not used directly in run-time code.  As shown below, such variables
can be directly accessed in one nimbleFunction from another, which
provides a way of using nimbleFunctions as general data structures.
To force NIMBLE to include variables around during compilation, for
example \cd{X} and \cd{Y}, simply include

<<eval = FALSE>>=
setupOutputs(X, Y)
@ 

anywhere in the \cd{setup} code. 

\section{Writing run code}
\label{sec:nimble-lang-comp}

In Section \ref{sec:nimble-lang-comp-simple} we described the functionality of the NIMBLE language that could be used in run code in which models were not used. When writing nimbleFunction run code that interacts with models, one can use that functionality already described as well as the functionality discussed in this section. 

\subsection{Driving models: \cd{calculate}, \cd{calculateDiff},
  \cd{simulate}, \cd{getLogProb}}
\label{sec:driv-models:-calc}

These four functions are the primary ways to operate a model.  Their
syntax was explained in Section \ref{sec:cdcalc-cdsim-cdgetl}. Except
for \cd{getLogProb}, it is usually important for the \cd{nodes}
object to be created in \cd{setup} code such that they are sorted in
topological order, and functions such as \cd{getDependencies} and
\cd{expandNodeNames} will
always do so.

It is possible to use an entire vector of node names, 
single elements indexed by a variable, or fixed ranges (indexed by constants)
, but not ranges indexed by a variable.  For
example

<<eval=FALSE>>=
myModel$calculate(nodes)
@ 
and
<<eval=FALSE>>=
myModel$calculate(nodes[i])
@ 
and
<<eval=FALSE>>=
myModel$calculate(nodes[1:3])
@ 
will all compile correctly, but
<<eval=FALSE>>=
myModel$calculate(nodes[1:i])
@ 
is not allowed.

\subsection{Accessing model and modelValues variables and using \cd{copy}}
\label{sec:access-model-modelv}

{\color{red} TODO: see what of this info is specific to nf usage and put in good location in this chapter}


The \cd{modelValues} structure was introduced in Section
\ref{sec:modelValues-struct}.  Inside nimbleFunctions, modelValues are
designed to easily save values from a model object during the running
of a nimbleFunction. A \cd{modelValues} object used in \cd{run} code
must always exist in the setup code, either by passing it in as a
setup argument or creating it in the setup code.
  
To illustrate this, we will create a nimbleFunction for computing
importance weights for importance sampling. This function will use two
modelValues objects.  \cd{propModelValues} will contain a set of
values simulated from the importance sampling distribution and a field \cd{propLL}
for their log
probabilities (densities).  \cd{savedWeights} will contain the
difference in log probability (density) between the model and the
\cd{propLL} value provided for each set of values.   

<<mv-setup-code>>=
@
  
  The simplest way to pass values back and forth between models and
  modelValues inside of a nimbleFunction is with \cd{copy}, which
  has the synonym \cd{nimCopy}. See \cd{help(nimCopy)} for argument details.
  
  %% This takes arguments 
  %% \begin{description}
  %% \item[\cd{from}, \cd{to}] which can either be models or modelValues
  %% \item[\cd{row}, \cd{rowTo}] which refers to the rows of a
  %%   modelValues object, if either \cd{from} or \cd{to} is a
  %%   modelValues. If \cd{rowTo} is omitted, it is assumed to be equal to \cd{row} if necessary.
  %%   \item[\cd{nodes}, \cd{nodesTo}] which is a vector of the names of the nodes
  %%     to be copied.  The node names will be expanded when variable names are provided.  If
  %%     \cd{nodesTo} is omitted it will be set equal to \cd{nodes}.
  %% \end{description}
  
%  TODO: CHECK THESE USAGES
  
  Alternatively, the values may be accessed via indexing of individual
  rows, using the notation \cd{mv[var, i]}, where \cd{mv} is a
  modelValues object, \cd{var} is a variable name (not a node name),
  and \cd{i} is a row number. Likewise, the \cd{getsize} and
  \cd{resize} functions can be used as discussed previously. However the function
  \cd{as.matrix} does not work in \cd{run} code.
  
  Here is a \cd{run} function to use these modelValues:
  
<<mv-run-time>>=
@

Once the nimbleFunction is built, the modelValues object can be accessed
using \cd{\$}, which is shown in more detail below.  In
fact, since modelValues, like most NIMBLE objects, are reference class
objects, one can get a reference to them before the function is
executed and then use that reference afterwards.
  
<<mv-compilation-example>>=
@

Importance sampling could also be written using simple vectors for the
weights, but we illustrated putting them in a modelValues object along
with model variables.

\subsection{Using model variables and modelValues in expressions}
\label{sec:using-model-variable}

Each way of accessing a variable, node, or modelValues can be used amid mathematical
expressions, including with indexing, or passed to another
nimbleFunction as an argument.  For example, the following two
statements would be valid:

<<eval = FALSE>>=
model[['x[2:8, ]']][2:4, 1:3] %*% Z
@ 
if Z is a vector or matrix, and

<<eval = FALSE>>=
C[6:10] <- mv[v, i][1:5, k] + B
@ 
if B is a vector or matrix.

The NIMBLE language allows scalars, but models defined from BUGS code
are never created as purely
scalar nodes.  Instead, a single node such as defined by \cd{z $\sim$
  dnorm(0, 1)} is implemented as a vector of length 1, similar to R.
When using z via \cd{model\$z} or \cd{model[[`z']]}, NIMBLE
will try to do the right thing by treating this as a scalar.  In the
event of problems\footnote{please tell us!}, a more explicit way to
access z is \cd{model\$z[1]} or \cd{model[[`z']][1]}.

\subsection{Getting and setting more than one model node or variable
  at a time using \cd{values}}
\label{sec:getting-setting-more}

Sometimes it is useful to set a collection of nodes or variables at
one time.  For example, one might want a nimbleFunction that will
serve as the objective function for an optimizer.  The input to the
nimbleFunction would be a vector, which should be used to fill a
collection of nodes in the model before calculating their log
probabilities.  This can be done using \cd{values()}:

<<eval=FALSE>>=
## get values from a set of model nodes into a vector
P <- values(model, nodes)
## or put values from a vector into a set of model nodes
values(model, nodes) <- P
@ 

where the first line would assign the collection of values from nodes
into P, and the second would to the inverse.  In both cases, values
from nodes with 2 or more dimensions are flattened into a vector in
column-wise order.

\cd{values(model, nodes)} may be used as a
vector in other expressions, e.g. \cd{Y <- A \%*\% values(model,
  nodes) + b}. 


\subsection{Including other methods in a nimbleFunction}
\label{sec:incl-other-meth}

Other methods can be included with the \cd{methods} argument to
\cd{nimbleFunction}.  These methods can use the objects created in
\cd{setup} code in just the same ways as the \cd{run} function.  In
fact, the \cd{run} function is just a default main method name. Any method can then call another method.

<<usingMemberFunctions>>=
@ 

\subsection{Using other nimbleFunctions}
\label{sec:using-other-nimbl}

One nimbleFunction can use another nimbleFunction that was passed to
it as a setup argument or was created in the setup function.  This can
be an effective way to program.  When a nimbleFunction needs to
access a setup variable or method of another nimbleFunction, use
\cd{\$}. 

<<owningMemberFunctions>>=
@ 

Note that the output from the \cd{print} calls in the compiled
function match those from the uncompiled function when run in an R
session.  It may not be shown here because this document is created with
\cd{knitr} and for some reason output printed from C++ does not make it into
\cd{knitr} output.

\subsection{Virtual nimbleFunctions and nimbleFunctionLists}
\label{sec:virt-nimbl-nimbl}

Often it is useful for one nimbleFunction to have a list of other
nimbleFunctions that have methods with the same arguments and return
types.  For example, NIMBLE's MCMC contains a list of samplers that
are each nimbleFunctions.

To make such a list, NIMBLE provides a way to declare the arguments
and return types of methods: virtual nimbleFunctions created by
\cd{nimbleFunctionVirtual}.  Other nimbleFunctions can inherit from
virtual nimbleFunctions, which in R is called ``containing'' them.
Readers familiar with object oriented programming will recognize this
as a simple class inheritance system.  In v\ver\ it is limited to
simple, single-level inheritance.

Here is how it works:

<<nimbleFunctionLists>>=
@ 


As in R, the
\cd{seq\_along} function is equivalent to
\cd{1:length(nimFunList)} if \cd{length(nimFunList)} $>$ 0, and
it is an empty sequence if \cd{length(nimFunList)} == 0.

Currently \cd{seq\_along} works only for nimbleFunctionLists.

Virtual nimbleFunctions cannot define \cd{setup} values to be inherited.


\subsection{Character objects}

NIMBLE provides limited uses of character objects in \cd{run} code.
Character vectors created in \cd{setup} code will be available in
\cd{run} code, but the only thing you can really do with them is
include them in a \cd{print} or \cd{stop} statement.  

Note that character vectors of model node and variable names are
processed during compilation.  For example, in \cd{model[[node]]}, \cd{node}
may be a character object, and the NIMBLE compiler processes this
differently than \cd{print(``The node name was '', node)}.  In the
former, the NIMBLE compiler sets up a C++ pointer directly to the
\cd{node} in the \cd{model}, so that the character content of
\cd{node} is never needed in C++.  In the latter, \cd{node} is used as
a C++ string and therefore is needed in C++.


\subsection{User-defined data structures}
\label{sec:user-defined-data}

NIMBLE does not explicitly have user-defined data structures, but one
can use nimbleFunctions to achieve a similar effect.  To do so, one
can define setup code with whatever variables are wanted and ensure
they are compiled using \cd{setupOutputs}.  Here is an example:

<<dataStructures>>=
@ 

You'll notice that:
\begin{itemize}
\item After execution of the compiled function, access to
the \cd{X}, \cd{Y}, and \cd{Z} is the same as for the
uncompiled case. This occurs because \cd{CmyUseDataNF} is an interface
to the compiled version of \cd{myUseDataNF}, and it provides access to
member objects and functions.  In this case, one member object is
\cd{myDataNF}, which is an interface to the compiled version of
\cd{myUseDataNF\$myDataNF}, which in turn provides access to \cd{X},
\cd{Y}, and \cd{Z}.  To reduce memory use, NIMBLE defaults to
\textit{not} providing full interfaces to nested nimbleFunctions like
\cd{myUseDataNF\$myDataNF}.  In this example we made it provide full
interfaces by setting the
\cd{buildInterfacesForCompiledNestedNimbleFunctions} option via
\cd{nimbleOptions} to TRUE.  If we had left that option FALSE (its
default value), we could still get to the values of interest using

<<eval=FALSE>>=
valueInCompiledNimbleFunction(CmyDataNF, 'X')
@ 

\item We need to take care that at the time of compilation, the
  \cd{X}, \cd{Y} and \cd{Z} values contain doubles via
  \cd{as.numeric} so that they are not compiled as integer objects.
\item The \cd{myDataNF} could be created in the setup code.  We just
  provided it as a setup argument to illustrate that option.
\end{itemize}


\section{Example: writing user-defined samplers to extend NIMBLE's MCMC engine}
\label{sec:user-samplers}

One important use of nimbleFunctions is to write additional samplers that can be used in NIMBLE's MCMC engine. This allows a user to write a custom sampler for one or more nodes in a model, as well as for programmers to provide general samplers for use in addition to the library of samplers provided with NIMBLE. 

The following code illustrates how a NIMBLE developer would implement and use a Metropolis-Hastings random walk sampler with fixed proposal standard deviation.  The comments accompanying the code explain the necessary characteristics of all sampler functions.

{\color{red} TODO: move the comments on the requirements into standard text. Also, more extended user-defined samplers are in the user\_sampler module of our outreach - may want more of that here.}

<<custom-sampler, eval=FALSE>>=
## the name of this sampler function, for the purposes of 
## adding it to MCMC configurations, will be 'my_RW'
my_RW <- nimbleFunction(

    ## sampler functions must contain 'sampler_BASE'
    contains = sampler_BASE,
    
    ## sampler functions must have exactly these setup arguments:
    ## model, mvSaved, target, control
    setup = function(model, mvSaved, target, control) {
        ## first, extract the control list elements, which will
        ## dictate the behavior of this sampler.
        ## the setup code will be later processed to determine
        ## all named elements extracted from the control list.
        ## these will become the required elements for any 
        ## control list argument to this sampler, unless they also
        ## exist in the NIMBLE system option 'MCMCcontrolDefaultList'.
        
        ## the random walk proposal standard deviation
        scale <- control$scale
        
        ## determine the list of all dependent nodes,
        ## up to the first layer of stochastic nodes, generally
        ## called 'calcNodes'.  The values, inputs, and logProbs
        ## of these nodes will be retrieved and/or altered
        ## by this algorithm.
        calcNodes <- model$getDependencies(target)
    },
    
    ## the run function must accept no arguments, execute 
    ## the sampling algorithm, leave the modelValues object
    ## 'mvSaved' as an exact copy of the updated values in model,
    ## and have no return value.  initially, mvSaved contains
    ## an exact copy of the values and logProbs in the model.
    run = function() {
        
        ## extract the initial model logProb
        model_lp_initial <- getLogProb(model, calcNodes)
        
        ## generate a proposal value for target node
        proposal <- rnorm(1, model[[target]], scale)
        
        ## store this proposed value into the target node.
        ## notice the double assignment operator, `<<-`,
        ## necessary because 'model' is a persistent member
        ## data object of this sampler.
        model[[target]] <<- proposal
        
        ## calculate target_logProb, propagate the 
        ## proposed value through any deterministic dependents,
        ## and calculate the logProb for any stochastic
        ## dependnets.  The total (sum) logProb is returned.
        model_lp_proposed <- calculate(model, calcNodes)
        
        ## calculate the log Metropolis-Hastings ratio
        log_MH_ratio <- model_lp_proposed - model_lp_initial
        
        ## Metropolis-Hastings step: determine whether or
        ## not to accept the newly proposed value
        u <- runif(1, 0, 1)
        if(u < exp(log_MH_ratio)) jump <- TRUE
        else                      jump <- FALSE
        
        ## if we accepted the proposal, then store the updated
        ## values and logProbs from 'model' into 'mvSaved'.
        ## if the proposal was not accepted, restore the values
        ## and logProbs from 'mvSaved' back into 'model'.
        if(jump) copy(from = model, to = mvSaved, row = 1, 
                         nodes = calcNodes, logProb = TRUE)
        else     copy(from = mvSaved, to = model, row = 1,
                         nodes = calcNodes, logProb = TRUE)
    },
    
    ## sampler functions must have a member method 'reset',
    ## which takes no arguments and has no return value.
    ## this function is used to reset the sampler to its
    ## initial state.  since this sampler function maintains
    ## no internal member data variables, reset() needn't
    ## do anything.
    methods = list(
        reset = function () {}
    )
)

## now, assume the existence of an R model object 'Rmodel',
## which has a scalar-valued stochastic node 'x'

## create an MCMC configuration with no sampler functions
mcmcConf <- configureMCMC(Rmodel, nodes = NULL)

## add our custom-built random walk sampler on node 'x',
## with a fixed proposal standard deviation = 0.1
mcmcConf$addSampler(target = 'x', type = 'my_RW',
    control = list(scale = 0.1))

Rmcmc <- buildMCMC(mcmcConf)   ## etc...
@

\section{Debugging nimbleFunctions}

{\color{red} TODO: basic info on inserting browser in nf run code and running in R as well as using debug(nf\$run)}

\section{Some options for reducing memory usage}

{\color{red} TODO: needs to be revised so only memory use is covered here and other material is moved as appropriate}

NIMBLE can make a lot of objects in its processing, and some of them
use R features like reference classes that are not light in memory
usage.  We have noticed that building large models can use lots of
memory.  To help alleviate this, we provide two options, which can be
controlled via \cd{nimbleOptions}.

As noted above, the option \cd{buildInterfacesForCompiledNestedNimbleFunctions} 
defaults to FALSE, which means NIMBLE will not build full interfaces to compiled
nimbleFunctions that ony appear within other nimbleFunctions.  If you
want access to all such nimbleFunctions, use the option 
\cd{buildInterfacesForCompiledNestedNimbleFunctions = TRUE}.

The option \cd{clearNimbleFunctionsAfterCompiling} is more drastic, and it is
experimental, so ``buyer beware''.  This will clear much of the
contents of an uncompiled nimbleFunction object after it has been
compiled in an effort to free some memory.  We expect to be able to
keep making NIMBLE more efficient -- faster execution and lower memory
use -- in the future.


%% \subsection{rankSample}
%% \label{sec:ranksample}

