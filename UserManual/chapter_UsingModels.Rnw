\Sexpr{set_parent('NimbleUserManual.Rnw')}

<<echo=FALSE>>=
require(nimble)
@ 

\chapter{Working with NIMBLE models}
\label{cha:using-bugs-models}

{\color{red} TODO: add forward references to writingNimbleFunctions}

\section{Variables and nodes in NIMBLE models}
\label{sec:accessing-variables}

Section \ref{sec:nodes-and-variables} describes what variables and nodes are in a NIMBLE model and how to nodes and their dependency relationships. 
Here we review some of NIMBLE's functionality for determining and accessing variables and nodes in a model. 

\subsection{Determining the variables and nodes in a model}

Model variables can be accessed and set just as in R using \cd{\$} and
\cd{[[ ]]}.  For example

<<usingModelVars>>=
@ 

While nodes that are part of a variable can be accessed as above, each
node also has its own name that can be used to access it directly.  For
example, \cd{y[2]} has the name ``y[2]'' and can be accessed by that
name as follows:

<<usingNodeNames>>=
@ 

Notice that node names can include index blocks, such as \cd{model[[`z[2:4, 1:2]']]}, and these are not strictly required to correspond to actual nodes.  Such blocks can be subsequently sub-indexed in the regular R manner.

The definitive source for node names in a model is
\cd{getNodeNames}, described below.  For example

<<multivariateDecExample>>=
@ 

You can see one lifted node for the Cholesky decomposition of
\cd{cov}, and the two multivariate normal nodes.

In the event you need to ensure that a name is formatted correctly,
you can use the \cd{expandNodeNames} method. For
example, to get the spaces correctly inserted into ``X[1,1:5]'':

<<multivariateExpandNodeNames>>=
@ 

Alternatively, for those inclined to R's less commonly used features, a nice trick is
to use its \cd{parse} and \cd{deparse} functions.  
<<>>=
deparse(parse(text = "X[1,1:5]", keep.source = FALSE)[[1]])
@ 


The \cd{keep.source = FALSE} makes \cd{parse} more efficient.


As discussed in Section \ref{sec:cdisdata}, you can determine whether a node is flagged as data using \cd{isData}. 


\subsection{Determining dependencies in a model}
\label{sec:cdgetdependencies}

Next we'll see how to determine the node dependencies (or
``descendants'') in a model. There are a variety of arguments to \cd{getDependencies} that
allow one to specify whether to include the node itself, whether to
include deterministic or stochastic or data dependents, etc. By
default \cd{getDependencies} returns descendants up to the next
stochastic node on all edges emanating from the node(s) specified as input.  This is what would be
needed to calculate a Metropolis-Hastings acceptance probability in
MCMC, for example.

<<getDependencies>>=
@ 

\subsection{Understanding lifted nodes}
\label{sec:introduced-nodes}

In some cases, NIMBLE introduces new nodes into the model that were
not specified in the BUGS code for the model, such as the
\cd{lifted\_d1\_over\_beta} node in the introductory example.  For
this reason, it is important that programs written to adapt to
different model structures use NIMBLE's systems for querying the model
graph.  For example, a call to \cd{pump\$getDependencies("beta")} will
correctly include \cd{lifted\_d1\_over\_beta}  in the results.  If one
skips this step and assumes the nodes are only those that appear in
the BUGS code, one may not get correct results.

It can be helpful to know the situations in which lifted nodes are
generated.  These include:

\begin{itemize}
\item When distribution parameters are expressions, NIMBLE
  creates a new deterministic node that contains the expression for a
  given parameter. The node is then a direct descendant of the new
  deterministic node.  This is an optional feature, but it is
  currently enabled in all cases.
\item As discussed in Section \ref{subsec:BUGS-link} the use of link
  functions causes new nodes to be introduced. This requires care if
  you need to initialize values in stochastic declarations with link functions.
\item Use of alternative parameterizations of distributions, described in Section \ref{subsec:dists-and-functions}. For
  example when a user provides the precision of a normal distribution
  as \cd{tau}, NIMBLE creates a new node \cd{sd <- 1/sqrt(tau)} and
  uses \cd{sd} as a parameter in the normal distribution.  If many
  nodes use the same \cd{tau}, only one new \cd{sd} node will be
  created, so the computation \cd{1/sqrt(tau)} will not be repeated
  redundantly.    
\end{itemize}

\section{Accessing information about nodes and variables}
\label{sec:nodeInfo}

NIMBLE provides an extensive set of functions to get information about
one or more nodes or variables in a model, as well as the current values of parameters and bounds for nodes.

While all of this functionality can be used from R, the primary use of getting information about nodes and variables is in nimbleFunctions. Information about node types, distributions, and dimensions can be used to determine algorithm behavior in setup code, while information about parameter and bound values would generally be used for algorithm calculations in run code.

\subsection{Getting distributional information about a node}

We briefly demonstrate some of the functionality for information about a node here,
but refer readers to the R help on \cd{modelBaseClass} for full details.

Here is an example model, with use of various functions to determine
information about nodes or variables.

<<distAPI-example>>=
code <- nimbleCode({
    for(i in 1:4) 
        y[i] ~ dnorm(mu, sd = sigma)
    mu ~ T(dnorm(0, 5), -20, 20)
    sigma ~ dunif(0, 10)
    })
m <- nimbleModel(code, data = list(y = rnorm(4)),
                           inits = list(mu = 0, sigma = 1))
m$isEndNode('y')
m$getDistribution('sigma')
m$isDiscrete(c('y', 'mu', 'sigma'))
m$isDeterm('mu')
m$getDimension('mu')
m$getDimension('mu', includeParams = TRUE)
@ 

Note that any variables provided to these functions are expanded into
their constituent node names, so the length of results may not be the
same length as the input vector of node and variable names. However
the order of the results should be preserved relative to the order of
the inputs, once the expansion is accounted for. 

\subsection{Getting information about a distribution}

One can also get generic information about a distribution based on the
name of the distribution. 
In particular, one can determine whether a distribution
was provided by the user (\cd{isUserDefined}), whether a distribution provides CDF and
quantile functions (\cd{pqDefined}), whether a distribution is a
discrete distribution (\cd{isDiscrete}), the parameter names (include
alternative parameterizations) for a distribution (\cd{getParamNames}),
and the dimension of the distribution and its parameters
(\cd{getDimension}).  For more extensive information, please see the R
help for \cd{getDistributionInfo}.

\subsection{Getting distribution parameter values for a node}
\label{sec:getParam}

The function \cd{getParam} provides access to values of the parameters
of a node's distribution.  Like the above functions, \cd{getParam} can be
used as  global function taking a model as the first argument, or it
can be used as a model member function.  The next two arguments must
be the name of one (stochastic) node and the name of a parameter for the
distribution followed by that node.  The parameter does not have to be
one of the parameters used when the node was declared.  Alternative
parameterization values can also be obtained. See
section(\ref{subsec:distributions}) for available parameterizations.
(These can also be seen via \cd{distributionsInputList}.) 

Here is an example:
<<getParamExample, message=FALSE>>=
gammaModel <- nimbleModel(
    nimbleCode({
        a ~ dlnorm(0, 1)
        x ~ dgamma(shape = 2, scale = a)
    }), data = list(x = 2.4), inits = list(a = 1.2))
getParam(gammaModel, 'x', 'scale')
getParam(gammaModel, 'x', 'rate')
gammaModel$getParam('x','rate')
@ 

\cd{getParam} also works in compiled nimbleFunctions.

\subsection{Getting distribution bounds for a node}
\label{sec:getBound}

The function \cd{getBound} provides access to the lower and upper
bounds of the distribution for a node. In most cases these bounds
will be fixed based on the distribution, but for the uniform distribution
the bounds are the parameters of the distribution, and when truncation (see
Section \ref{subsec:trunc}) is used, the bounds will be determined 
by the truncation. Like the functions described in the previous section, \cd{getBound} can be
used as  global function taking a model as the first argument, or it
can be used as a model member function.  The next two arguments must
be the name of one (stochastic) node and either \cd{'lower'} or \cd{'upper'}
indicating whether the lower or upper bound is desired. For multivariate nodes
the bound is a scalar that is the bound for all elements of the node, as we
do not handle truncation for multivariate nodes. 

Here is an example:
<<getBoundExample, message=FALSE>>=
exampleModel <- nimbleModel(
    nimbleCode({
        y ~ T(dnorm(mu, sd = sig), a, Inf)
        a ~ dunif(-1, b)
        b ~ dgamma(1, 1)
    }), inits = list(a = -0.5, mu = 1, sig = 1, b = 4),
        data = list(y = 4))
getBound(exampleModel, 'y', 'lower')
getBound(exampleModel, 'y', 'upper')
exampleModel$b <- 3
exampleModel$calculate(exampleModel$getDependencies('b'))
getBound(exampleModel, 'a', 'upper')
exampleModel$getBound('b','lower')
@ 

\cd{getBound} also works in compiled nimbleFunctions. In fact, we anticipate that
most use of \cd{getBound} will be for algorithms, such as for the reflection
version of the random walk MCMC sampler.




\section{Carrying out model calculations}
  %\cd{calculate}, \cd{calculateDiff}, \cd{simulate}, and \cd{getLogProb}
\label{sec:cdcalc-cdsim-cdgetl}

\subsection{Core model operations: calculation and simulation}

The four basic ways to operate a model are to calculate nodes,
simulate into nodes, get the log probabilities (or probability
densities) that have already been calculated, and compare the log probability
of a new value to that of an old value.  In more detail:

\begin{description}
\item[calculate] For a stochastic node,
\cd{calculate} determines the log probability value, stores it in the
appropriate \cd{logProb} variable, and
returns it.  For a deterministic node, \cd{calculate} executes the
deterministic calculation and returns 0.
\item[simulate] For a stochastic node, \cd{simulate} generates a
  random draw.  For deterministic nodes,
\cd{simulate} is equivalent to \cd{calculate} without returning
0. \cd{simulate} always returns \cd{NULL} (or \cd{void} in C++).
\item[getLogProb]   \cd{getLogProb} simply
returns the most recently calculated log probability value, or 0 for a
deterministic node.
\item[calculateDiff]  \cd{calculateDiff} is identical to
  \cd{calculate}, but it returns the new log probability value minus
  the one that was previously stored. This is useful when one wants to
  change the value or values of node(s) in the model (e.g., by setting a value or 
  \cd{simulate}) and then determine
  the change in the log probability, such as needed for a
  Metropolis-Hastings acceptance probability. 
\end{description}

Each of these functions is accessed as a member function of a model
object, taking a vector of node names as an argument.   If there is
more than one node name, \cd{calculate} and \cd{getLogProb} return the
sum of the log probabilities from each node, while \cd{calculateDiff}
returns the sum of the new values minus the old values.  Next we show
an example using \cd{simulate}

\subsection{\cd{simNodes}, \cd{calcNodes}, and \cd{getLogProbs}}
\label{sec:cdsimn-cdcalcn-cdget}



  \cd{simNodes}, \cd{calcNodes} and \cd{getLogProb} are basic nimbleFunctions that simulate, calculate, or get the log probabilities
  (densities), respectively, of the same set of nodes each time they
  are called.  Each of these 
takes a model and a character string of node names 
  as inputs. If \cd{nodes} is left blank, then all the nodes of the model
  are used. 
  
  For \cd{simNodes}, the nodes provided will be topologically sorted to 
  simulate in the correct order. For \cd{calcNodes} and \cd{getLogProb},
  the nodes will be sorted and dependent nodes will be included.  Recall that
 the calculations must be up to date (from a calculate call) for \cd{getLogProb} 
  to return the values you are probably looking for.
  
<<Basic_Utils_Algs>>=
simpleModelCode <- nimbleCode({
  for(i in 1:4){
    x[i] ~ dnorm(0,1)
    y[i] ~ dnorm(x[i], 1) #y depends on x
    z[i] ~ dnorm(y[i], 1) #z depends on y
    #z conditionally independent of x
  }
})

simpleModel <- nimbleModel(simpleModelCode, check = FALSE)
cSimpleModel <- compileNimble(simpleModel)

#simulates all the x's and y's
rSimXY <- simNodes(simpleModel, nodes = c('x', 'y') ) 

#calls calculate on x and its dependents (y, but not z)
rCalcXDep <- calcNodes(simpleModel, nodes = 'x')

#calls getLogProb on x's and y's
rGetLogProbXDep <- getLogProbNodes(simpleModel,
                  nodes = 'x')

#compiling the functions
cSimXY <- compileNimble(rSimXY, project = simpleModel)
cCalcXDep <- compileNimble(rCalcXDep, project = simpleModel)
cGetLogProbXDep <- compileNimble(rGetLogProbXDep,
                           project = simpleModel)

cSimpleModel$x
cSimpleModel$y
#simulating x and y
cSimXY$run()
cSimpleModel$x
cSimpleModel$y

cCalcXDep$run()

#Gives correct answer because logProbs
#updated by 'calculate' after simulation
cGetLogProbXDep$run()

cSimXY$run()

#Gives old answer because logProbs
#not updated after 'simulate'
cGetLogProbXDep$run()
cCalcXDep$run()
@

 
\subsection{Example: simulating arbitrary collections of nodes}
\label{sec:arbitr-coll-nodes}

<<calcSimGLPdemos,results='markup;$=\\$'>>=
@ 

Note the following.
\begin{enumerate}
\item \cd{simulate(model, nodes)} is equivalent to
  \cd{model\$simulate(nodes)}. You can use either, but the latter is
  encouraged and the former may be deprecated inthe future.
\item Inputs like \cd{`y[1:3]'} are automatically expanded into
  \cd{c(`y[1]', `y[2]', `y[3]')}.  In fact, simply \cd{`y'} will be
  expanded into all nodes within \cd{y}.
\item An arbitrary number of nodes can be provided as a character
vector.
\item Simulations will be done in the order provided, so in practice
  the nodes should often be obtained by functions like
  \cd{getDependencies} described below.  These return nodes in
  topologically sorted order, which means no node comes before something
  it depends on.
\item The data nodes \cd{z} were not simulated into until
  \cd{includeData = TRUE} was used.
\end{enumerate}

Use of \cd{calculate}, \cd{calculateDiff} and \cd{getLogProb} are similar to \cd{simulate},
except that they return a value (described above) and they have no \cd{includeData} argument.


\subsection{Accessing log probabilities via logProb variables}
\label{sec:access-log-prob}

For each variable that contains at least one stochastic node, NIMBLE generates a model variable with the
prefix  ``logProb\_''.  When the stochastic node is scalar, the
\cd{logProb} variable will have the same size.  For example:

<<usingModelLogProbs>>=
@ 

Creation of \cd{logProb} variables for stochastic multivariate nodes
is trickier, because they can represent an arbitrary block of a larger
variable.  In general NIMBLE records the logProb values using
the lowest possible indices.  For example, if \cd{x[5:10, 15:20]}
follows a Wishart distribution, its log probability (density) value
will be stored in \cd{logProb\_x[5, 15]}.  When possible, NIMBLE will
reduce the dimensions of the corresponding logProb variable.  For
example, in

<<eval = FALSE>>=
for(i in 1:10) x[i,] ~ dmnorm(mu[], prec[,])
@ 

\cd{x} may be 10$\times$20 (dimensions must be provided), but \cd{logProb\_x}
will be 10$\times$1.  For the most part you do not need to worry about
how NIMBLE is storing the log probability values, because you can
always get them using \cd{getLogProb}.  


\section{The \nm{modelValues} data structure}
\label{sec:modelValues-struct}

\cd{modelValues} are containers designed for
storing values for models.  They may be used for model outputs or
model inputs. A modelValues object will contain \emph{rows} of
variables. Each row  contains one object of each variable, which may
be multivariate. The simplest way to build a
modelValues object is from a model object. This will create a
modelValues object with the same variables as the model.  Although
they were motivated by models, one is free to set up a
\cd{modelValues} with any variables one wants.
  
<<intro-mv>>=
pumpModelValues = modelValues(pumpModel, m = 2)
pumpModel$x
pumpModelValues$x
@


In this example, \cd{pumpModelValues} has the same variables as
\cd{pumpModel}, and we set \cd{pumpModelValues} to have \cd{m = 2}
rows. As you can see, the rows are stored as elements of a list.
  
  Alternatively, one can define a modelValues object manually via the
  \cd{modelValuesConf} function, like this:
%%   \begin{itemize}
%%  \item \cd{vars}, which is a character vector of variable names, 
%%    \item \cd{type}, which is a character vector of the data types for each variable (`double' for real numbers, `integer' for integers) and 
%%      \item \cd{size}, which is a list of vectors of the sizes in each dimension of each variable. The names of the list elements must match the names provided in \cd{vars}. 
%% \end{itemize}

<<mvConf>>=
mvConf = modelValuesConf(vars = c('a', 'b', 'c'), 
                         type = c('double', 'int', 'double'), 
                         size = list( a = 2, b =c(2,2)  , c = 1) )

customMV = modelValues(mvConf, m = 2 )
customMV$a
@

The arguments to \cd{modelValuesConf} are matching lists of variable
names, types, and sizes. See \cd{help(modelValuesConf)} for more
details.  Note that in R execution, the types are not enforced.  But
they will be the types created in C++ code during compilation, so they
should be specified carefully.

The object returned by \cd{modelValues} is an uncompiled
modelValues. When a nimbleFunction is compiled, any modelValues
objects it uses are also compiled. A NIMBLE model always contains a
modelValues that it uses as a default location to store its variables.

Here is an example where the \cd{customMV} created above is used as
the setup argument for a nimbleFunction, which is then compiled.  Its
compiled mv is then accessed with \cd{\$}.

<<resize_MV>>=
# Simple nimbleFunction that uses a modelValues object
resizeFunction_Gen <- nimbleFunction(
  setup = function(mv){},
  run = function(k = integer() ){
    resize(mv,k)})

rResize <- resizeFunction_Gen(customMV)
cResize <- compileNimble(rResize)
cCustomMV <- cResize$mv
# cCustomMV is a C++ modelValues object
@

Compiled modelValues objects can be accessed and altered in all the
same ways as uncompiled ones.  However, only uncompiled modelValues
can be used as arguments to setup code in nimbleFunctions.

\subsection{Accessing contents of modelValues}
\label{sec:access-cont-modelv}

The values in a modelValues object can be accessed in several ways
from R, and in fewer ways from NIMBLE.

<<mv-access>>=
# Sets the first row of a to (0, 1).  R only.
customMV[['a']][[1]] <- c(0,1)   

# Sets the second row of a to (2, 3)
customMV['a', 2] <- c(2,3)       

#Can access subsets of each row in standard R manner
customMV['a', 2][2] <- 4

# Accesses all values of 'a'. Output is a list.  R only.
customMV[['a']]                  

# Sets the first row of b to a matrix with values 1. R only.
customMV[['b']][[1]] <- matrix(1, nrow = 2, ncol = 2)  

# Sets the second row of b.  R only.
customMV[['b']][[2]] <- matrix(2, nrow = 2, ncol = 2)  

# Make sure the size of inputs is correct
# customMV['a', 1] <- 1:10  
# Problem: dimension of 'a' is 2, not 10!
# Will cause problems when compiling nimbleFunction using customMV
@

Currently, only the syntax \cd{customMV[`a', 2]} works in the NIMBLE
language, not \cd{customMV[[`a']][[2]]}. Also note that \cd{c()} does not work in NIMBLE, but one can do \cd{customMV[`a', 2] <- X[1:2]}.

We can query and change the number of rows using \cd{getsize} and
\cd{resize}, respectively.  These work in both R and NIMBLE.  Note
that we don't specify the variables in this case: all variables in a
modelValues object will have the same number of rows.
  
<<resize-mv>>=
getsize(customMV)
resize(customMV, 3)
getsize(customMV)
customMV$a
@

Often it is useful to convert a modelValues object to a matrix for use
in R.  For example, we may want to convert MCMC output into a matrix
for use with the \cd{coda} package for processing MCMC samples. This
can be done with the \cd{as.matrix} method for modelValues
objects. This will generate column names from every scalar element of
variables (e.g. "x[1, 1]" ,"x[2, 1]", etc.). The rows of
the modelValues will be the rows of the matrix, with any matrices or
arrays converted to a vector based on column-major ordering.
  
<<as.matrix-mv>>=
as.matrix(customMV, 'a')   # convert 'a'
as.matrix(customMV)        # convert all variables
@

If a variable is a scalar, using \cd{unlist} in R to extract all rows as a vector can be useful.

<<extract_MV_Vector>>=
customMV['c', 1] <- 1
customMV['c', 2] <- 2
customMV['c', 3] <- 3
unlist(customMV['c', ])
@

Once we have a modelValues object, we can see the structure of its
contents via the \cd{varNames} and \cd{sizes} components of the object.

<<mv_VarNames_Sizes>>=
customMV$varNames
customMV$sizes
@

As with most NIMBLE objects, modelValues are passed by reference, not
by value. That means any modifications of modelValues objects in
either R functions or \cd{nimbleFunction}s will persist outside of the
function. This allows for more efficient computation, as stored values
are immediately shared among \cd{nimbleFunction}s.

<<alter_a>>=
alter_a <- function(mv){
  mv['a',1][1] <- 1
}
customMV['a', 1]

alter_a(customMV)
customMV['a',1]

#Note that the first row was changed
@

However, when you retrieve a variable from a modelValues object, the result is a standard R list, which is subsequently passed by value, as usual in R.

\subsection{Accessing model and modelValues variables and using \cd{copy}}
\label{sec:access-model-modelv}

{\color{red} TODO: revise this to just talk about access and use of copy and not about nf's}

The \cd{modelValues} structure was introduced in Section
\ref{sec:modelValues-struct}.  Inside nimbleFunctions, modelValues are
designed to easily save values from a model object during the running
of a nimbleFunction. A \cd{modelValues} object used in \cd{run} code
must always exist in the setup code, either by passing it in as a
setup argument or creating it in the setup code.
  
To illustrate this, we will create a nimbleFunction for computing
importance weights for importance sampling. This function will use two
modelValues objects.  \cd{propModelValues} will contain a set of
values simulated from the importance sampling distribution and a field \cd{propLL}
for their log
probabilities (densities).  \cd{savedWeights} will contain the
difference in log probability (density) between the model and the
\cd{propLL} value provided for each set of values.   

<<mv-setup-code>>=
@
  
  The simplest way to pass values back and forth between models and
  modelValues inside of a nimbleFunction is with \cd{copy}, which
  has the synonym \cd{nimCopy}. See \cd{help(nimCopy)} for argument details.
  
  %% This takes arguments 
  %% \begin{description}
  %% \item[\cd{from}, \cd{to}] which can either be models or modelValues
  %% \item[\cd{row}, \cd{rowTo}] which refers to the rows of a
  %%   modelValues object, if either \cd{from} or \cd{to} is a
  %%   modelValues. If \cd{rowTo} is omitted, it is assumed to be equal to \cd{row} if necessary.
  %%   \item[\cd{nodes}, \cd{nodesTo}] which is a vector of the names of the nodes
  %%     to be copied.  The node names will be expanded when variable names are provided.  If
  %%     \cd{nodesTo} is omitted it will be set equal to \cd{nodes}.
  %% \end{description}
  
%  TODO: CHECK THESE USAGES
  
  Alternatively, the values may be accessed via indexing of individual
  rows, using the notation \cd{mv[var, i]}, where \cd{mv} is a
  modelValues object, \cd{var} is a variable name (not a node name),
  and \cd{i} is a row number. Likewise, the \cd{getsize} and
  \cd{resize} functions can be used as discussed previously. However the function
  \cd{as.matrix} does not work in \cd{run} code.
  
  Here is a \cd{run} function to use these modelValues:
  
<<mv-run-time>>=
@

Once the nimbleFunction is built, the modelValues object can be accessed
using \cd{\$}, which is shown in more detail below.  In
fact, since modelValues, like most NIMBLE objects, are reference class
objects, one can get a reference to them before the function is
executed and then use that reference afterwards.
  
<<mv-compilation-example>>=
@

Importance sampling could also be written using simple vectors for the
weights, but we illustrated putting them in a modelValues object along
with model variables.


\subsubsection{\cd{simNodesMV}, \cd{calcNodesMV}, and \cd{getLogProbsMV}}

There is a similar trio of nimbleFunctions that does each job
repeatedly for different rows of a modelValues object.  For example,
\cd{simNodesMV} will simulate in the model multiple times and record
each simulation in a row of its modelValues.  \cd{calcNodesMV} and
\cd{getLogProbsMV} iterate over the rows of a modelValues, copy the
nodes into the model, and then do their job of calculating or
collecting log probabilities (densities), respectively.  Each of these
returns a numeric vector with the summed log probabilities of the
chosen nodes from each
each row. \cd{calcNodesMV} will 
  save the log probabilities back into the modelValues object if
  \cd{saveLP == TRUE}, a run-time argument. 

Here are some examples:

<<Basic_Utils_MV>>=
mv <- modelValues(simpleModel)
rSimManyXY <- simNodesMV(simpleModel, nodes = c('x', 'y'), mv = mv)
rCalcManyXDeps <- calcNodesMV(simpleModel, nodes = 'x', mv = mv)
rGetLogProbMany <- getLogProbNodesMV(simpleModel,
                    nodes = 'x', mv = mv)

cSimManyXY <- compileNimble(rSimManyXY, project = simpleModel)
cCalcManyXDeps <- compileNimble(rCalcManyXDeps, project = simpleModel)
cGetLogProbMany <- compileNimble(rGetLogProbMany, project = simpleModel)

cSimManyXY$run(m = 5) # simulating 5 times
cCalcManyXDeps$run(saveLP = TRUE) # calculating 
cGetLogProbMany$run() #
@
  
