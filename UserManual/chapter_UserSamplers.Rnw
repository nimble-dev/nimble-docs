\Sexpr{set_parent('NimbleUserManual.Rnw')}

<<echo=FALSE>>=
require(nimble)
@ 

\chapter{Extending NIMBLE's MCMC engine with user-defined samplers}
\label{cha:user-samplers}


The following code illustrates how a NIMBLE developer would implement and use a Metropolis-Hastings random walk sampler with fixed proposal standard deviation.  The comments accompanying the code explain the necessary characteristics of all sampler functions.

<<custom-sampler, eval=FALSE>>=
## the name of this sampler function, for the purposes of 
## adding it to MCMC configurations, will be 'my_RW'
my_RW <- nimbleFunction(

    ## sampler functions must contain 'sampler_BASE'
    contains = sampler_BASE,
    
    ## sampler functions must have exactly these setup arguments:
    ## model, mvSaved, target, control
    setup = function(model, mvSaved, target, control) {
        ## first, extract the control list elements, which will
        ## dictate the behavior of this sampler.
        ## the setup code will be later processed to determine
        ## all named elements extracted from the control list.
        ## these will become the required elements for any 
        ## control list argument to this sampler, unless they also
        ## exist in the NIMBLE system option 'MCMCcontrolDefaultList'.
        
        ## the random walk proposal standard deviation
        scale <- control$scale
        
        ## determine the list of all dependent nodes,
        ## up to the first layer of stochastic nodes, generally
        ## called 'calcNodes'.  The values, inputs, and logProbs
        ## of these nodes will be retrieved and/or altered
        ## by this algorithm.
        calcNodes <- model$getDependencies(target)
    },
    
    ## the run function must accept no arguments, execute 
    ## the sampling algorithm, leave the modelValues object
    ## 'mvSaved' as an exact copy of the updated values in model,
    ## and have no return value.  initially, mvSaved contains
    ## an exact copy of the values and logProbs in the model.
    run = function() {
        
        ## extract the initial model logProb
        model_lp_initial <- getLogProb(model, calcNodes)
        
        ## generate a proposal value for target node
        proposal <- rnorm(1, model[[target]], scale)
        
        ## store this proposed value into the target node.
        ## notice the double assignment operator, `<<-`,
        ## necessary because 'model' is a persistent member
        ## data object of this sampler.
        model[[target]] <<- proposal
        
        ## calculate target_logProb, propagate the 
        ## proposed value through any deterministic dependents,
        ## and calculate the logProb for any stochastic
        ## dependnets.  The total (sum) logProb is returned.
        model_lp_proposed <- calculate(model, calcNodes)
        
        ## calculate the log Metropolis-Hastings ratio
        log_MH_ratio <- model_lp_proposed - model_lp_initial
        
        ## Metropolis-Hastings step: determine whether or
        ## not to accept the newly proposed value
        u <- runif(1, 0, 1)
        if(u < exp(log_MH_ratio)) jump <- TRUE
        else                      jump <- FALSE
        
        ## if we accepted the proposal, then store the updated
        ## values and logProbs from 'model' into 'mvSaved'.
        ## if the proposal was not accepted, restore the values
        ## and logProbs from 'mvSaved' back into 'model'.
        if(jump) copy(from = model, to = mvSaved, row = 1, 
                         nodes = calcNodes, logProb = TRUE)
        else     copy(from = mvSaved, to = model, row = 1,
                         nodes = calcNodes, logProb = TRUE)
    },
    
    ## sampler functions must have a member method 'reset',
    ## which takes no arguments and has no return value.
    ## this function is used to reset the sampler to its
    ## initial state.  since this sampler function maintains
    ## no internal member data variables, reset() needn't
    ## do anything.
    methods = list(
        reset = function () {}
    )
)

## now, assume the existence of an R model object 'Rmodel',
## which has a scalar-valued stochastic node 'x'

## create an MCMC configuration with no sampler functions
mcmcConf <- configureMCMC(Rmodel, nodes = NULL)

## add our custom-built random walk sampler on node 'x',
## with a fixed proposal standard deviation = 0.1
mcmcConf$addSampler(target = 'x', type = 'my_RW',
    control = list(scale = 0.1))

Rmcmc <- buildMCMC(mcmcConf)   ## etc...
@








